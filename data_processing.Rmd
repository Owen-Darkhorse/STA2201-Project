---
title: "dataclean2"
output: html_document
date: "2025-02-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)

# Step 1: List all the CSV files in the current directory
file_list <- list.files(path = ".", pattern = "^sub-.*\\.csv$", full.names = TRUE)

# Step 2: Read and combine all CSV files
df <- file_list %>%
  set_names() %>%
  map_dfr(~ read.csv(.x, check.names = FALSE), .id = "filename")

# Step 3: Check the result
head(df)


```


```{r}
names(df)
```

```{r}
library(tibble)

electrode_coords <- tibble::tribble(
  ~electrode, ~x,   ~y,   ~z,   ~region,
  "Fp1",     -0.5,  1.0,  0.8, "Frontal",
  "Fp2",      0.5,  1.0,  0.8, "Frontal",
  "F3",      -0.6,  0.5,  0.9, "Frontal",
  "F4",       0.6,  0.5,  0.9, "Frontal",
  "C3",      -0.8,  0.0,  0.9, "Central",
  "C4",       0.8,  0.0,  0.9, "Central",
  "P3",      -0.6, -0.5,  0.8, "Parietal",
  "P4",       0.6, -0.5,  0.8, "Parietal",
  "O1",      -0.5, -1.0,  0.7, "Occipital",
  "O2",       0.5, -1.0,  0.7, "Occipital",
  "F7",      -1.0,  0.6,  0.6, "Frontal",
  "F8",       1.0,  0.6,  0.6, "Frontal",
  "T3",      -1.2,  0.0,  0.5, "Temporal",
  "T4",       1.2,  0.0,  0.5, "Temporal",
  "T5",      -1.0, -0.6,  0.6, "Temporal",
  "T6",       1.0, -0.6,  0.6, "Temporal",
  "Fz",       0.0,  0.8,  0.9, "Frontal",
  "Cz",       0.0,  0.0,  1.0, "Central",
  "Pz",       0.0, -0.8,  0.9, "Parietal"
)


```


```{r}
# Load needed libraries
library(tidyverse)

# Get all electrode pairs (unique combinations)
electrode_pairs <- combn(electrode_coords$electrode, 2, simplify = FALSE) %>%
  map_df(~ tibble(e1 = .x[1], e2 = .x[2]))

# Join coordinates for both electrodes in each pair
electrode_pairs <- electrode_pairs %>%
  left_join(electrode_coords, by = c("e1" = "electrode")) %>%
  rename_with(~ paste0("e1_", .), c(x, y, z, region)) %>%
  left_join(electrode_coords, by = c("e2" = "electrode")) %>%
  rename_with(~ paste0("e2_", .), c(x, y, z, region)) %>%
  mutate(
    distance = sqrt((e1_x - e2_x)^2 + (e1_y - e2_y)^2 + (e1_z - e2_z)^2),
    region_pair = paste(pmin(e1_region, e2_region), pmax(e1_region, e2_region), sep = "-")
  )


electrode_pairs <- electrode_pairs %>%
  mutate(pair_name = paste(e1, e2, sep = "-"))
```

```{r}
electrode_pairs 
```
```{r}
install.packages("signal")
install.packages("pracma")

```


```{r}
library(signal)
library(pracma)

compute_plv_matrix <- function(data, fs = 1000, fmin = 8, fmax = 12) {
  n_channels <- ncol(data)
  n_samples <- nrow(data)
  
  # Bandpass filter
  bf <- butter(4, c(fmin, fmax)/(fs/2), type = "pass")
  filtered <- apply(data, 2, function(x) filtfilt(bf, x))
  
  # Hilbert transform to get phase
  phase <- apply(filtered, 2, function(x) Arg(hilbert(x)))
  
  # Compute PLV matrix
  plv_mat <- matrix(0, n_channels, n_channels)
  for (i in 1:(n_channels-1)) {
    for (j in (i+1):n_channels) {
      diff_phase <- phase[, i] - phase[, j]
      plv_val <- abs(mean(exp(1i * diff_phase)))
      plv_mat[i, j] <- plv_val
      plv_mat[j, i] <- plv_val
    }
  }
  diag(plv_mat) <- 1
  colnames(plv_mat) <- colnames(data)
  rownames(plv_mat) <- colnames(data)
  return(plv_mat)
}

library(igraph)

extract_graph_metrics <- function(plv_matrix, subject_id) {
  g <- graph_from_adjacency_matrix(plv_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

  tibble(
    subject = subject_id,
    degree_mean = mean(degree(g)),
    clustering_mean = mean(transitivity(g, type = "localundirected", isolates = "zero"))
  )
}


```


```{r}
hilbert_transform <- function(x) {
  N <- length(x)
  Xf <- fft(x)
  
  h <- rep(0, N)
  if (N %% 2 == 0) {
    h[c(1, N/2 + 1)] <- 1
    h[2:(N/2)] <- 2
  } else {
    h[1] <- 1
    h[2:((N + 1)/2)] <- 2
  }

  x_hilbert <- fft(Xf * h, inverse = TRUE) / N
  return(x_hilbert)
}

```


```{r}
subject_ids <- unique(df$filename)

library(signal)  # for butter + filtfilt

compute_plv_matrix <- function(data, fs = 1000, fmin = 8, fmax = 12) {
  n_channels <- ncol(data)

  # Bandpass filter (e.g., alpha)
  bf <- butter(4, c(fmin, fmax) / (fs / 2), type = "pass")
  filtered <- apply(data, 2, function(x) filtfilt(bf, x))

  # Get phase from Hilbert transform
  phase <- apply(filtered, 2, function(x) Arg(hilbert_transform(x)))

  # Compute PLV matrix
  plv_mat <- matrix(0, n_channels, n_channels)
  for (i in 1:(n_channels - 1)) {
    for (j in (i + 1):n_channels) {
      diff_phase <- phase[, i] - phase[, j]
      plv_val <- abs(mean(exp(1i * diff_phase)))
      plv_mat[i, j] <- plv_val
      plv_mat[j, i] <- plv_val
    }
  }

  diag(plv_mat) <- 1
  colnames(plv_mat) <- colnames(data)
  rownames(plv_mat) <- colnames(data)
  return(plv_mat)
}


library(igraph)

extract_graph_metrics <- function(plv_matrix, subject_id) {
  g <- graph_from_adjacency_matrix(plv_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

  tibble(
    subject = subject_id,
    degree_mean = mean(degree(g)),
    clustering_mean = mean(transitivity(g, type = "localundirected", isolates = "zero"))
  )
}

# Now apply to each subject in your combined df
graph_results <- map_dfr(subject_ids, function(subj) {
  cat("Processing:", subj, "\n")

  subject_data <- df %>%
    dplyr::filter(filename == subj) %>%
    select(-filename)


  if (nrow(subject_data) < 1000) {
    warning(paste("Skipping", subj, ": not enough data"))
    return(NULL)
  }

  plv_matrix <- compute_plv_matrix(subject_data)
  extract_graph_metrics(plv_matrix, subject_id = subj)
})

print(graph_results)

```
```{r}
subj <- "./sub-001.csv"

library(dplyr)

# Filter the subject's data
subject_data <- df %>%
  dplyr::filter(filename == subj) %>%
  dplyr::select(-filename)

dim(subject_data)       # e.g., 300000 x 19
head(subject_data[, 1]) # first few values of Fp1


plv_matrix <- compute_plv_matrix(subject_data)

summary(as.vector(plv_matrix))

hist(plv_matrix[upper.tri(plv_matrix)], breaks = 30, main = "PLV Distribution")
```

```{r}
library(signal)

# Bandpass filter
fs <- 1000
bf <- butter(4, c(8, 12) / (fs / 2), type = "pass")
filtered_fp1 <- filtfilt(bf, subject_data$Fp1)

# Hilbert transform
analytic_fp1 <- hilbert_transform(filtered_fp1)
phase_fp1 <- Arg(analytic_fp1)

# Plot original vs filtered vs phase
plot(subject_data$Fp1[1:1000], type = "l", col = "black", main = "Fp1 Channel (First 1s)")
lines(filtered_fp1[1:1000], col = "blue")
lines(phase_fp1[1:1000], col = "red")
legend("topright", legend = c("Raw", "Filtered", "Phase"), col = c("black", "blue", "red"), lty = 1)

```


```{r}
# Hilbert phase from two channels
phase_1 <- Arg(hilbert_transform(filtfilt(bf, subject_data$Fp1)))
phase_2 <- Arg(hilbert_transform(filtfilt(bf, subject_data$F3)))

# Plot phase difference
plot(phase_1 - phase_2, type = "l", main = "Phase Difference: Fp1 - F3")

```
```{r}
normalize <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}

subject_data_norm <- as.data.frame(lapply(subject_data, normalize))

plv_matrix_norm <- compute_plv_matrix(subject_data_norm)
summary(as.vector(plv_matrix_norm))  # Check that values vary now!

hist(plv_matrix_norm[upper.tri(plv_matrix_norm)], breaks = 30, main = "PLV Distribution (Normalized)")

```


# updated option 1

```{r}
library(tibble)

electrode_coords <- tibble::tribble(
  ~electrode, ~x,   ~y,   ~z,   ~region,
  "Fp1",     -0.5,  1.0,  0.8, "Frontal",
  "Fp2",      0.5,  1.0,  0.8, "Frontal",
  "F3",      -0.6,  0.5,  0.9, "Frontal",
  "F4",       0.6,  0.5,  0.9, "Frontal",
  "C3",      -0.8,  0.0,  0.9, "Central",
  "C4",       0.8,  0.0,  0.9, "Central",
  "P3",      -0.6, -0.5,  0.8, "Parietal",
  "P4",       0.6, -0.5,  0.8, "Parietal",
  "O1",      -0.5, -1.0,  0.7, "Occipital",
  "O2",       0.5, -1.0,  0.7, "Occipital",
  "F7",      -1.0,  0.6,  0.6, "Frontal",
  "F8",       1.0,  0.6,  0.6, "Frontal",
  "T3",      -1.2,  0.0,  0.5, "Temporal",
  "T4",       1.2,  0.0,  0.5, "Temporal",
  "T5",      -1.0, -0.6,  0.6, "Temporal",
  "T6",       1.0, -0.6,  0.6, "Temporal",
  "Fz",       0.0,  0.8,  0.9, "Frontal",
  "Cz",       0.0,  0.0,  1.0, "Central",
  "Pz",       0.0, -0.8,  0.9, "Parietal"
)

library(dplyr)

# Generate all unique channel pairs
electrode_pairs <- combn(electrode_coords$electrode, 2, simplify = FALSE) %>%
  map_df(~ tibble(e1 = .x[1], e2 = .x[2]))

# Join metadata and calculate Euclidean distance + region labels
electrode_pairs <- electrode_pairs %>%
  left_join(electrode_coords, by = c("e1" = "electrode")) %>%
  rename_with(~ paste0("e1_", .), c(x, y, z, region)) %>%
  left_join(electrode_coords, by = c("e2" = "electrode")) %>%
  rename_with(~ paste0("e2_", .), c(x, y, z, region)) %>%
  mutate(
    distance = sqrt((e1_x - e2_x)^2 + (e1_y - e2_y)^2 + (e1_z - e2_z)^2),
    region_pair = paste(pmin(e1_region, e2_region), pmax(e1_region, e2_region), sep = "-"),
    pair_label = paste(e1, e2, sep = "-")
  )

plv_matrix <- compute_plv_matrix(subject_data_norm)

channel_names <- colnames(plv_matrix)

# Get names of all upper triangle pairs
pair_labels <- combn(channel_names, 2, simplify = FALSE) %>%
  map_chr(~ paste(.x, collapse = "-"))

plv_values <- plv_matrix[upper.tri(plv_matrix)]
plv_df <- tibble(
  pair_label = pair_labels,
  plv = plv_values
)

plv_annotated <- plv_df %>%
  left_join(electrode_pairs, by = "pair_label")

```

```{r}
library(ggplot2)

ggplot(plv_annotated, aes(x = distance, y = plv)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(title = "PLV vs Electrode Distance",
       x = "Distance between electrodes",
       y = "PLV") +
  theme_minimal()

```

```{r}
ggplot(plv_annotated, aes(x = region_pair, y = plv)) +
  geom_boxplot(fill = "lightblue") +
  coord_flip() +
  labs(title = "PLV by Region Pair",
       x = "Region Pair",
       y = "PLV") +
  theme_minimal()

```


```{r}
filter <- dplyr::filter
select <- dplyr::select


library(readr)
library(dplyr)

# Step 1: Read participant metadata
participants <- read_tsv("participants.tsv")

# Step 2: List only the files you're working with
files_in_analysis <- c(
  "sub-001", "sub-003", "sub-004", "sub-005",
  "sub-037", "sub-038", "sub-039", "sub-041",
  "sub-042", "sub-066", "sub-068", "sub-069",
  "sub-070", "sub-071"
)

# Step 3: Filter participants for these subjects only
participants_filtered <- participants %>%
  filter(participant_id %in% files_in_analysis) %>%
  mutate(subject = participant_id)


```
```{r}
library(tidyverse)
library(signal)

# Your Hilbert transform function
hilbert_transform <- function(x) {
  N <- length(x)
  Xf <- fft(x)
  h <- rep(0, N)
  if (N %% 2 == 0) {
    h[c(1, N/2 + 1)] <- 1
    h[2:(N/2)] <- 2
  } else {
    h[1] <- 1
    h[2:((N + 1)/2)] <- 2
  }
  fft(Xf * h, inverse = TRUE) / N
}

# Normalize function
normalize <- function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)

# Compute PLV
compute_plv_matrix <- function(data, fs = 1000, fmin = 8, fmax = 12) {
  bf <- butter(4, c(fmin, fmax) / (fs / 2), type = "pass")
  filtered <- apply(data, 2, function(x) filtfilt(bf, x))
  phase <- apply(filtered, 2, function(x) Arg(hilbert_transform(x)))
  
  n <- ncol(data)
  plv <- matrix(0, n, n)
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      plv[i, j] <- abs(mean(exp(1i * (phase[, i] - phase[, j]))))
      plv[j, i] <- plv[i, j]
    }
  }
  diag(plv) <- 1
  colnames(plv) <- colnames(data)
  rownames(plv) <- colnames(data)
  return(plv)
}

# Electrode metadata (from earlier)
# Assume 'electrode_coords' already defined

# Pair metadata
electrode_pairs <- combn(electrode_coords$electrode, 2, simplify = FALSE) %>%
  map_df(~ tibble(e1 = .x[1], e2 = .x[2])) %>%
  left_join(electrode_coords, by = c("e1" = "electrode")) %>%
  rename_with(~ paste0("e1_", .), c(x, y, z, region)) %>%
  left_join(electrode_coords, by = c("e2" = "electrode")) %>%
  rename_with(~ paste0("e2_", .), c(x, y, z, region)) %>%
  mutate(
    distance = sqrt((e1_x - e2_x)^2 + (e1_y - e2_y)^2 + (e1_z - e2_z)^2),
    region_pair = paste(pmin(e1_region, e2_region), pmax(e1_region, e2_region), sep = "-"),
    pair_label = paste(e1, e2, sep = "-")
  )

# 📂 List your files
files <- list.files(pattern = "^sub-.*\\.csv$")

# ⛏ Process all files
plv_all_subjects <- map_dfr(files, function(file) {
  message("Processing ", file)
  df <- read.csv(file, check.names = FALSE)
  df_norm <- as.data.frame(lapply(df, normalize))
  plv <- compute_plv_matrix(df_norm)

  # Flatten PLV
  pair_labels <- combn(colnames(plv), 2, simplify = FALSE) %>%
    map_chr(~ paste(.x, collapse = "-"))
  plv_values <- plv[upper.tri(plv)]

  tibble(
    pair_label = pair_labels,
    plv = plv_values,
    subject = tools::file_path_sans_ext(basename(file))
  ) %>%
    left_join(electrode_pairs, by = "pair_label")
})

```


```{r}
plv_all_subjects  # should have a column 'subject' like "sub-001"

```

```{r}
plv_all <- plv_all_subjects %>%
  left_join(participants_filtered, by = "subject")

```



```{r}
library(ggplot2)

ggplot(plv_all, aes(x = Group, y = plv)) +
  geom_violin(fill = "lightblue") +
  geom_boxplot(width = 0.1) +
  labs(title = "PLV by Group (A vs C)", y = "PLV") +
  theme_minimal()

```


```{r}
plv_stats <- plv_all %>%
  group_by(pair_label) %>%
  summarize(
    p = tryCatch(wilcox.test(plv ~ Group)$p.value, error = function(e) NA),
    mean_A = mean(plv[Group == "A"], na.rm = TRUE),
    mean_C = mean(plv[Group == "C"], na.rm = TRUE)
  ) %>%
  arrange(p)

head(plv_stats, 10)  # show top 10 most different connections

```

```{r}
write.csv(plv_all, "plv_all_subjects_groupA_vs_C.csv", row.names = FALSE)
write.csv(plv_stats, "plv_group_diff_stats.csv", row.names = FALSE)

```


# remove diagonal and compare

```{r}
library(readr)
library(dplyr)

# 读取 participants.tsv 并构造 subject 列（和 plv_all_subjects 对应）
participants <- read_tsv("participants.tsv") %>%
  mutate(subject = participant_id)

plv_all <- plv_all_subjects %>%
  left_join(participants, by = "subject")

head(plv_stats, 10)

library(ggplot2)

top_pair <- plv_stats$pair_label[1]

ggplot(plv_all %>% filter(pair_label == top_pair), 
       aes(x = Group, y = plv, fill = Group)) +
  geom_boxplot() +
  labs(
    title = paste("Top PLV Difference Between Groups for", top_pair),
    y = "PLV", x = "Group"
  ) +
  theme_minimal()

```


```{r}
library(ggplot2)

# Get the most different pair (lowest p-value)
top_pair <- plv_stats$pair_label[1]

# Make violin plot
ggplot(plv_all %>% filter(pair_label == top_pair), 
       aes(x = Group, y = plv, fill = Group)) +
  geom_violin(trim = FALSE, color = NA, alpha = 0.7) +
  geom_boxplot(width = 0.1, outlier.shape = NA, fill = "white", alpha = 0.4) +
  labs(
    title = paste("PLV Distribution by Group for", top_pair),
    subtitle = paste("Wilcoxon p =", signif(plv_stats$p[1], 3)),
    x = "Group", y = "PLV"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")

```


```{r}
top_n <- 5  # 你可以改成 10、15 等
top_pairs <- plv_stats %>%
  arrange(p) %>%
  slice(1:top_n) %>%
  pull(pair_label)

```


```{r}
library(ggplot2)

ggplot(plv_all %>% filter(pair_label %in% top_pairs),
       aes(x = Group, y = plv, fill = Group)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA, alpha = 0.4) +
  facet_wrap(~ pair_label, scales = "free_y") +
  labs(
    title = paste("PLV Distributions for Top", top_n, "Connections"),
    y = "PLV", x = "Group"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")

```


